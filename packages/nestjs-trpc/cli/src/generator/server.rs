use crate::generator::StaticGenerator;
use crate::{ProcedureMetadata, RouterMetadata};
use std::collections::{HashMap, HashSet};
use std::path::Path;

const GENERATED_FILE_HEADER: &str = "\
/**
 * AUTO-GENERATED FILE - DO NOT EDIT!
 *
 * This file was automatically generated by nestjs-trpc.
 * Any manual changes will be overwritten on the next generation.
 *
 * Command: `npx nestjs-trpc generate`
 * Learn more: https://nestjs-trpc.io
 */
";

#[derive(Debug, Clone)]
pub struct ServerGenerator {
    static_generator: StaticGenerator,

    indent: String,
}

impl Default for ServerGenerator {
    fn default() -> Self {
        Self::new()
    }
}

impl ServerGenerator {
    #[must_use]
    pub fn new() -> Self {
        Self {
            static_generator: StaticGenerator::new(),
            indent: "  ".to_string(),
        }
    }

    #[must_use]
    pub fn with_static_generator(mut self, generator: StaticGenerator) -> Self {
        self.static_generator = generator;
        self
    }

    #[must_use]
    pub fn with_indent(mut self, indent: &str) -> Self {
        self.indent = indent.to_string();
        self
    }

    #[must_use]
    pub const fn static_generator(&self) -> &StaticGenerator {
        &self.static_generator
    }

    #[must_use]
    pub fn generate(&self, routers: &[RouterMetadata]) -> String {
        let mut output = String::new();

        output.push_str(GENERATED_FILE_HEADER);
        output.push('\n');

        output.push_str(&self.static_generator.generate_static_declarations());

        output.push('\n');

        output.push_str(&self.generate_app_router(routers, None));

        output.push('\n');

        output.push_str(&self.generate_app_router_type_export());

        output
    }

    #[must_use]
    pub fn generate_with_schema_imports(
        &self,
        routers: &[RouterMetadata],
        schema_locations: &HashMap<String, std::path::PathBuf>,
        output_file_path: &Path,
    ) -> String {
        let mut output = String::new();

        output.push_str(GENERATED_FILE_HEADER);
        output.push('\n');

        output.push_str(&self.static_generator.generate_static_declarations());

        let schema_names: Vec<&str> = routers
            .iter()
            .flat_map(|r| &r.procedures)
            .flat_map(Self::extract_schema_refs)
            .collect();

        self.append_schema_imports(
            &mut output,
            &schema_names,
            schema_locations,
            output_file_path,
        );

        let owner_imports = self.collect_owner_imports(routers, output_file_path);
        self.append_owner_module_type_aliases(&mut output, &owner_imports);
        if !owner_imports.is_empty() {
            output.push_str(&self.generate_owner_return_type_helper());
            output.push('\n');
        }

        output.push('\n');

        output.push_str(&self.generate_app_router(routers, Some(output_file_path)));

        output.push('\n');

        output.push_str(&self.generate_app_router_type_export());

        output
    }

    #[must_use]
    pub fn generate_app_router(
        &self,
        routers: &[RouterMetadata],
        output_file_path: Option<&Path>,
    ) -> String {
        let term = self.terminator();

        if routers.is_empty() {
            return format!("const appRouter = t.router({{}}){term}\n");
        }

        let merged = merge_routers_by_key(routers);
        let router_strings: Vec<String> = merged
            .iter()
            .map(|(key, procedures)| {
                self.generate_merged_router_string(key, procedures, 1, output_file_path)
            })
            .collect();

        let routers_content = router_strings.join(",\n");

        format!("const appRouter = t.router({{\n{routers_content}\n}}){term}\n")
    }

    fn generate_merged_router_string(
        &self,
        router_key: &str,
        procedures: &[&ProcedureMetadata],
        depth: usize,
        output_file_path: Option<&Path>,
    ) -> String {
        let indent = self.indent.repeat(depth);
        let inner_indent = self.indent.repeat(depth + 1);

        if procedures.is_empty() {
            return format!("{indent}{router_key}: t.router({{}})");
        }

        let procedure_strings: Vec<String> = procedures
            .iter()
            .map(|procedure| self.generate_procedure_string(procedure, depth + 1, output_file_path))
            .collect();

        let procedures_content = procedure_strings.join(",\n");

        format!("{indent}{router_key}: t.router({{\n{procedures_content}\n{inner_indent}}})")
    }

    #[must_use]
    pub fn generate_router_string(
        &self,
        router: &RouterMetadata,
        depth: usize,
        output_file_path: Option<&Path>,
    ) -> String {
        let indent = self.indent.repeat(depth);
        let inner_indent = self.indent.repeat(depth + 1);

        let router_key = router
            .alias
            .clone()
            .unwrap_or_else(|| to_camel_case(&router.name));

        if router.procedures.is_empty() {
            return format!("{indent}{router_key}: t.router({{}})");
        }

        let procedure_strings: Vec<String> = router
            .procedures
            .iter()
            .map(|proc| self.generate_procedure_string(proc, depth + 1, output_file_path))
            .collect();

        let procedures_content = procedure_strings.join(",\n");

        format!("{indent}{router_key}: t.router({{\n{procedures_content}\n{inner_indent}}})")
    }

    #[must_use]
    pub fn generate_procedure_string(
        &self,
        procedure: &ProcedureMetadata,
        depth: usize,
        output_file_path: Option<&Path>,
    ) -> String {
        let indent = self.indent.repeat(depth);
        let chain_indent = self.indent.repeat(depth + 1);

        let mut chain_parts: Vec<String> = Vec::new();

        chain_parts.push(format!("{indent}{}: publicProcedure", procedure.name));

        if let Some(input) = &procedure.input_schema {
            chain_parts.push(format!("{chain_indent}.input({input})"));
        }

        if let Some(output) = &procedure.output_schema {
            chain_parts.push(format!("{chain_indent}.output({output})"));
        }

        let resolver_cast = if procedure.output_schema.is_some() {
            "as any".to_string()
        } else {
            format!(
                "as unknown as {}",
                self.generate_return_type_expression(procedure, output_file_path)
            )
        };
        let proc_type = procedure.procedure_type.to_string();
        chain_parts.push(format!(
            "{chain_indent}.{proc_type}(async () => \"PLACEHOLDER_DO_NOT_REMOVE\" {resolver_cast})"
        ));

        chain_parts.join("\n")
    }

    fn generate_return_type_expression(
        &self,
        procedure: &ProcedureMetadata,
        output_file_path: Option<&Path>,
    ) -> String {
        if let (Some(output_file_path), Some(owner_file_path), Some(owner_class_name)) = (
            output_file_path,
            procedure.owner_file_path.as_deref(),
            procedure.owner_class_name.as_deref(),
        ) {
            let output_dir = output_file_path.parent().unwrap_or_else(|| Path::new("."));
            let import_path = calculate_relative_import_path(output_dir, owner_file_path);
            let owner_alias = owner_module_alias(owner_class_name, &import_path);

            return format!(
                "Awaited<__ResolveProcedureReturnType<{owner_alias}, \"{owner_class_name}\", \"{}\">>",
                procedure.name
            );
        }

        procedure
            .method_return_type
            .as_deref()
            .map_or("any".to_string(), |return_type| {
                format!("Awaited<{return_type}>")
            })
    }

    #[must_use]
    pub fn generate_app_router_type_export(&self) -> String {
        let term = self.terminator();
        format!("export type AppRouter = typeof appRouter{term}\n")
    }

    const fn terminator(&self) -> &str {
        if self.static_generator.use_semicolons {
            ";"
        } else {
            ""
        }
    }

    fn extract_schema_refs(procedure: &ProcedureMetadata) -> Vec<&str> {
        let input_ref = procedure.input_schema_ref.as_deref();
        let output_ref = procedure.output_schema_ref.as_deref();
        let mut refs: Vec<&str> = [input_ref, output_ref].into_iter().flatten().collect();
        refs.extend(procedure.schema_identifiers.iter().map(String::as_str));
        refs
    }

    fn append_schema_imports(
        &self,
        output: &mut String,
        schema_names: &[&str],
        schema_locations: &HashMap<String, std::path::PathBuf>,
        output_file_path: &Path,
    ) {
        if schema_names.is_empty() {
            return;
        }

        let schema_imports = self.static_generator.generate_schema_imports(
            schema_names.iter().copied(),
            schema_locations,
            output_file_path,
        );

        if !schema_imports.is_empty() {
            output.push_str(&schema_imports);
        }
    }

    fn collect_owner_imports(
        &self,
        routers: &[RouterMetadata],
        output_file_path: &Path,
    ) -> Vec<(String, String)> {
        let output_dir = output_file_path.parent().unwrap_or_else(|| Path::new("."));
        let mut seen_aliases: HashSet<String> = HashSet::new();
        let mut imports = Vec::new();

        for router in routers {
            for procedure in &router.procedures {
                if procedure.output_schema.is_some() {
                    continue;
                }

                let (Some(owner_file_path), Some(owner_class_name)) = (
                    procedure.owner_file_path.as_deref(),
                    procedure.owner_class_name.as_deref(),
                ) else {
                    continue;
                };

                let import_path = calculate_relative_import_path(output_dir, owner_file_path);
                let alias = owner_module_alias(owner_class_name, &import_path);
                if seen_aliases.insert(alias.clone()) {
                    imports.push((alias, import_path));
                }
            }
        }

        imports
    }

    fn append_owner_module_type_aliases(
        &self,
        output: &mut String,
        owner_imports: &[(String, String)],
    ) {
        if owner_imports.is_empty() {
            return;
        }

        let quote = if self.static_generator.use_single_quotes {
            '\''
        } else {
            '"'
        };
        let term = self.terminator();

        for (alias, import_path) in owner_imports {
            output.push_str(&format!(
                "type {alias} = typeof import({quote}{import_path}{quote}){term}\n"
            ));
        }

        output.push('\n');
    }

    fn generate_owner_return_type_helper(&self) -> String {
        let term = self.terminator();
        let type_body = "\
type __ResolveProcedureReturnType<
  TModule,
  TOwnerName extends string,
  TMethodName extends string,
> = TModule extends { readonly [K in TOwnerName]: infer TClass }
  ? TClass extends abstract new (...args: any[]) => any
    ? TMethodName extends keyof InstanceType<TClass>
      ? InstanceType<TClass>[TMethodName] extends (...args: any[]) => any
        ? ReturnType<InstanceType<TClass>[TMethodName]>
        : any
      : any
    : any
  : TModule extends { readonly default: infer TDefault }
    ? TDefault extends abstract new (...args: any[]) => any
      ? TMethodName extends keyof InstanceType<TDefault>
        ? InstanceType<TDefault>[TMethodName] extends (...args: any[]) => any
          ? ReturnType<InstanceType<TDefault>[TMethodName]>
          : any
        : any
      : any
    : any";
        format!("{type_body}{term}\n")
    }
}

fn to_camel_case(s: &str) -> String {
    let mut chars = s.chars();
    chars.next().map_or_else(String::new, |first| {
        first.to_lowercase().chain(chars).collect()
    })
}

fn merge_routers_by_key(routers: &[RouterMetadata]) -> Vec<(String, Vec<&ProcedureMetadata>)> {
    let mut key_order: Vec<String> = Vec::new();
    let mut merged: HashMap<String, Vec<&ProcedureMetadata>> = HashMap::new();

    for router in routers {
        let key = router
            .alias
            .clone()
            .unwrap_or_else(|| to_camel_case(&router.name));

        if !merged.contains_key(&key) {
            key_order.push(key.clone());
        }

        merged.entry(key).or_default().extend(&router.procedures);
    }

    key_order
        .into_iter()
        .filter_map(|key| merged.remove(&key).map(|procedures| (key, procedures)))
        .collect()
}

fn calculate_relative_import_path(from_dir: &Path, to_file: &Path) -> String {
    let relative = pathdiff::diff_paths(to_file, from_dir).map_or_else(
        || to_file.to_string_lossy().to_string(),
        |p| p.to_string_lossy().to_string(),
    );

    let relative = relative.replace('\\', "/");
    let without_ext = relative
        .strip_suffix(".ts")
        .or_else(|| relative.strip_suffix(".tsx"))
        .unwrap_or(&relative);

    if without_ext.starts_with('.') || without_ext.starts_with('/') {
        without_ext.to_string()
    } else {
        format!("./{without_ext}")
    }
}

const FNV_OFFSET_BASIS: u64 = 0xcbf29ce484222325;
const FNV_PRIME: u64 = 0x100000001b3;
const ALIAS_HASH_MASK: u64 = 0x00ff_ffff;

fn owner_module_alias(owner_class_name: &str, import_path: &str) -> String {
    let mut hash: u64 = FNV_OFFSET_BASIS;
    for byte in import_path.bytes() {
        hash ^= u64::from(byte);
        hash = hash.wrapping_mul(FNV_PRIME);
    }

    let sanitized_class_name: String = owner_class_name
        .chars()
        .filter(|ch| ch.is_ascii_alphanumeric() || *ch == '_')
        .collect();

    let class_name_part = if sanitized_class_name.is_empty() {
        "Owner".to_string()
    } else {
        sanitized_class_name
    };

    let short_hash = hash & ALIAS_HASH_MASK;
    format!("__{class_name_part}Module_{short_hash:06x}")
}

#[must_use]
pub fn generate_server_file(routers: &[RouterMetadata]) -> String {
    ServerGenerator::new().generate(routers)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{ProcedureMetadata, ProcedureType};

    fn create_test_procedure(
        name: &str,
        proc_type: ProcedureType,
        input: Option<&str>,
        output: Option<&str>,
    ) -> ProcedureMetadata {
        ProcedureMetadata {
            name: name.to_string(),
            procedure_type: proc_type,
            input_schema: input.map(std::string::ToString::to_string),
            output_schema: output.map(std::string::ToString::to_string),
            method_return_type: None,
            owner_class_name: None,
            owner_file_path: None,
            input_schema_ref: None,
            output_schema_ref: None,
            schema_identifiers: Vec::new(),
        }
    }

    fn create_test_router(
        name: &str,
        alias: Option<&str>,
        procedures: Vec<ProcedureMetadata>,
    ) -> RouterMetadata {
        RouterMetadata {
            name: name.to_string(),
            alias: alias.map(std::string::ToString::to_string),
            file_path: std::path::PathBuf::from("test.router.ts"),
            procedures,
        }
    }

    #[test]
    fn test_server_generator_creation() {
        let generator = ServerGenerator::new();
        assert_eq!(generator.indent, "  ");
    }

    #[test]
    fn test_server_generator_default() {
        let generator = ServerGenerator::default();
        assert_eq!(generator.indent, "  ");
    }

    #[test]
    fn test_to_camel_case() {
        assert_eq!(to_camel_case("UserRouter"), "userRouter");
        assert_eq!(to_camel_case("MyClass"), "myClass");
        assert_eq!(to_camel_case("ABC"), "aBC");
        assert_eq!(to_camel_case("a"), "a");
        assert_eq!(to_camel_case(""), "");
    }

    #[test]
    fn test_generate_procedure_string_query_with_input_output() {
        let generator = ServerGenerator::new();
        let procedure = create_test_procedure(
            "getUserById",
            ProcedureType::Query,
            Some("z.object({ userId: z.string() })"),
            Some("z.object({ name: z.string() })"),
        );

        let output = generator.generate_procedure_string(&procedure, 2, None);

        assert!(output.contains("getUserById: publicProcedure"));
        assert!(output.contains(".input(z.object({ userId: z.string() }))"));
        assert!(output.contains(".output(z.object({ name: z.string() }))"));
        assert!(output.contains(".query(async () => \"PLACEHOLDER_DO_NOT_REMOVE\" as any)"));
    }

    #[test]
    fn test_generate_procedure_string_mutation_with_input() {
        let generator = ServerGenerator::new();
        let procedure = create_test_procedure(
            "createUser",
            ProcedureType::Mutation,
            Some("z.object({ name: z.string() })"),
            None,
        );

        let output = generator.generate_procedure_string(&procedure, 2, None);

        assert!(output.contains("createUser: publicProcedure"));
        assert!(output.contains(".input(z.object({ name: z.string() }))"));
        assert!(!output.contains(".output"));
        assert!(output
            .contains(".mutation(async () => \"PLACEHOLDER_DO_NOT_REMOVE\" as unknown as any)"));
    }

    #[test]
    fn test_generate_procedure_string_subscription_with_input_output() {
        let generator = ServerGenerator::new();
        let procedure = create_test_procedure(
            "onMessage",
            ProcedureType::Subscription,
            Some("z.object({ channelId: z.string() })"),
            Some("z.object({ message: z.string() })"),
        );

        let output = generator.generate_procedure_string(&procedure, 2, None);

        assert!(output.contains("onMessage: publicProcedure"));
        assert!(output.contains(".input(z.object({ channelId: z.string() }))"));
        assert!(output.contains(".output(z.object({ message: z.string() }))"));
        assert!(output
            .contains(".subscription(async () => \"PLACEHOLDER_DO_NOT_REMOVE\" as any)"));
    }

    #[test]
    fn test_generate_procedure_string_query_no_input_no_output() {
        let generator = ServerGenerator::new();
        let procedure = create_test_procedure("getAll", ProcedureType::Query, None, None);

        let output = generator.generate_procedure_string(&procedure, 2, None);

        assert!(output.contains("getAll: publicProcedure"));
        assert!(!output.contains(".input"));
        assert!(!output.contains(".output"));
        assert!(
            output.contains(".query(async () => \"PLACEHOLDER_DO_NOT_REMOVE\" as unknown as any)")
        );
    }

    #[test]
    fn test_generate_procedure_string_infers_from_owner_method_when_output_missing() {
        let generator = ServerGenerator::new();
        let mut procedure = create_test_procedure("list", ProcedureType::Query, None, None);
        procedure.owner_class_name = Some("UserRouter".to_string());
        procedure.owner_file_path = Some(std::path::PathBuf::from("/workspace/src/user.router.ts"));

        let output_file_path = std::path::PathBuf::from("/workspace/generated/server.ts");
        let output = generator.generate_procedure_string(&procedure, 2, Some(&output_file_path));
        let owner_alias = owner_module_alias("UserRouter", "../src/user.router");

        assert!(
            output.contains(
                &format!(
                    ".query(async () => \"PLACEHOLDER_DO_NOT_REMOVE\" as unknown as Awaited<__ResolveProcedureReturnType<{owner_alias}, \"UserRouter\", \"list\">>)"
                )
            )
        );
    }

    #[test]
    fn test_generate_procedure_string_keeps_output_schema_as_priority_override() {
        let generator = ServerGenerator::new();
        let mut procedure = create_test_procedure(
            "list",
            ProcedureType::Query,
            None,
            Some("z.array(z.string())"),
        );
        procedure.method_return_type = Some("Promise<number[]>".to_string());
        procedure.owner_class_name = Some("UserRouter".to_string());
        procedure.owner_file_path = Some(std::path::PathBuf::from("/workspace/src/user.router.ts"));

        let output_file_path = std::path::PathBuf::from("/workspace/generated/server.ts");
        let output = generator.generate_procedure_string(&procedure, 2, Some(&output_file_path));

        assert!(output.contains(".output(z.array(z.string()))"));
        assert!(output.contains(".query(async () => \"PLACEHOLDER_DO_NOT_REMOVE\" as any)"));
    }

    #[test]
    fn test_generate_procedure_string_uses_method_return_type_when_owner_missing() {
        let generator = ServerGenerator::new();
        let mut procedure = create_test_procedure("getAll", ProcedureType::Query, None, None);
        procedure.method_return_type = Some("Promise<FooDto[]>".to_string());

        let output = generator.generate_procedure_string(&procedure, 2, None);

        assert!(!output.contains(".output"));
        assert!(
            output.contains(
                ".query(async () => \"PLACEHOLDER_DO_NOT_REMOVE\" as unknown as Awaited<Promise<FooDto[]>>)"
            )
        );
    }

    #[test]
    fn test_generate_with_schema_imports_adds_owner_type_import_and_helper() {
        let generator = ServerGenerator::new();
        let mut procedure = create_test_procedure("list", ProcedureType::Query, None, None);
        procedure.owner_class_name = Some("UserRouter".to_string());
        procedure.owner_file_path = Some(std::path::PathBuf::from("/workspace/src/user.router.ts"));

        let routers = vec![create_test_router(
            "UserRouter",
            Some("users"),
            vec![procedure],
        )];
        let schema_locations = HashMap::new();
        let output_path = std::path::PathBuf::from("/workspace/generated/server.ts");

        let output =
            generator.generate_with_schema_imports(&routers, &schema_locations, &output_path);
        let owner_alias = owner_module_alias("UserRouter", "../src/user.router");

        assert!(output.contains(&format!(
            "type {owner_alias} = typeof import(\"../src/user.router\");"
        )));
        assert!(output.contains("type __ResolveProcedureReturnType<"));
    }

    #[test]
    fn test_generate_router_string_with_alias() {
        let generator = ServerGenerator::new();
        let router = create_test_router(
            "UserRouter",
            Some("users"),
            vec![create_test_procedure(
                "getUser",
                ProcedureType::Query,
                None,
                None,
            )],
        );

        let output = generator.generate_router_string(&router, 1, None);

        assert!(output.contains("users: t.router({"));
        assert!(output.contains("getUser: publicProcedure"));
    }

    #[test]
    fn test_generate_router_string_without_alias() {
        let generator = ServerGenerator::new();
        let router = create_test_router(
            "UserRouter",
            None,
            vec![create_test_procedure(
                "getUser",
                ProcedureType::Query,
                None,
                None,
            )],
        );

        let output = generator.generate_router_string(&router, 1, None);

        // Should use camelCase class name
        assert!(output.contains("userRouter: t.router({"));
    }

    #[test]
    fn test_generate_router_string_empty_procedures() {
        let generator = ServerGenerator::new();
        let router = create_test_router("EmptyRouter", Some("empty"), vec![]);

        let output = generator.generate_router_string(&router, 1, None);

        assert!(output.contains("empty: t.router({})"));
    }

    #[test]
    fn test_generate_app_router_empty() {
        let generator = ServerGenerator::new();
        let output = generator.generate_app_router(&[], None);

        assert!(output.contains("const appRouter = t.router({});"));
    }

    #[test]
    fn test_generate_app_router_single_router() {
        let generator = ServerGenerator::new();
        let routers = vec![create_test_router(
            "UserRouter",
            Some("users"),
            vec![create_test_procedure(
                "getUser",
                ProcedureType::Query,
                None,
                None,
            )],
        )];

        let output = generator.generate_app_router(&routers, None);

        assert!(output.contains("const appRouter = t.router({"));
        assert!(output.contains("users: t.router({"));
        assert!(output.contains("getUser: publicProcedure"));
    }

    #[test]
    fn test_generate_app_router_multiple_routers() {
        let generator = ServerGenerator::new();
        let routers = vec![
            create_test_router(
                "UserRouter",
                Some("users"),
                vec![create_test_procedure(
                    "getUser",
                    ProcedureType::Query,
                    None,
                    None,
                )],
            ),
            create_test_router(
                "PostRouter",
                Some("posts"),
                vec![create_test_procedure(
                    "createPost",
                    ProcedureType::Mutation,
                    Some("z.object({ title: z.string() })"),
                    None,
                )],
            ),
        ];

        let output = generator.generate_app_router(&routers, None);

        assert!(output.contains("users: t.router({"));
        assert!(output.contains("posts: t.router({"));
        assert!(output.contains("getUser: publicProcedure"));
        assert!(output.contains("createPost: publicProcedure"));
    }

    #[test]
    fn test_generate_app_router_type_export() {
        let generator = ServerGenerator::new();
        let output = generator.generate_app_router_type_export();

        assert_eq!(output, "export type AppRouter = typeof appRouter;\n");
    }

    #[test]
    fn test_generate_complete_file() {
        let generator = ServerGenerator::new();
        let routers = vec![create_test_router(
            "UserRouter",
            Some("users"),
            vec![create_test_procedure(
                "getUserById",
                ProcedureType::Query,
                Some("z.object({ userId: z.string() })"),
                Some("z.object({ name: z.string(), email: z.string() })"),
            )],
        )];

        let output = generator.generate(&routers);

        // Check static declarations
        assert!(output.contains("import { initTRPC } from \"@trpc/server\";"));
        assert!(output.contains("import { z } from \"zod\";"));
        assert!(output.contains("const t = initTRPC.create();"));
        assert!(output.contains("const publicProcedure = t.procedure;"));

        // Check appRouter
        assert!(output.contains("const appRouter = t.router({"));
        assert!(output.contains("users: t.router({"));
        assert!(output.contains("getUserById: publicProcedure"));
        assert!(output.contains(".input(z.object({ userId: z.string() }))"));
        assert!(output.contains(".output(z.object({ name: z.string(), email: z.string() }))"));
        assert!(output.contains(".query(async () => \"PLACEHOLDER_DO_NOT_REMOVE\" as any)"));

        // Check type export
        assert!(output.contains("export type AppRouter = typeof appRouter;"));
    }

    #[test]
    fn test_generate_complete_file_empty_routers() {
        let generator = ServerGenerator::new();
        let output = generator.generate(&[]);

        assert!(output.contains("import { initTRPC }"));
        assert!(output.contains("import { z }"));
        assert!(output.contains("const appRouter = t.router({});"));
        assert!(output.contains("export type AppRouter = typeof appRouter;"));
    }

    #[test]
    fn test_generate_server_file_convenience_function() {
        let routers = vec![create_test_router(
            "TestRouter",
            Some("test"),
            vec![create_test_procedure(
                "testQuery",
                ProcedureType::Query,
                None,
                None,
            )],
        )];

        let output = generate_server_file(&routers);

        assert!(output.contains("test: t.router({"));
        assert!(output.contains("testQuery: publicProcedure"));
    }

    #[test]
    fn test_with_indent_configuration() {
        let generator = ServerGenerator::new().with_indent("\t");
        let procedure =
            create_test_procedure("getUser", ProcedureType::Query, Some("z.string()"), None);

        let output = generator.generate_procedure_string(&procedure, 1, None);

        assert!(output.contains("\t\t.input(z.string())"));
    }

    #[test]
    fn test_with_static_generator_configuration() {
        let static_gen = StaticGenerator::new().with_single_quotes(true);
        let generator = ServerGenerator::new().with_static_generator(static_gen);
        let routers = vec![create_test_router("Test", Some("test"), vec![])];

        let output = generator.generate(&routers);

        assert!(output.contains("import { initTRPC } from '@trpc/server';"));
        assert!(output.contains("import { z } from 'zod';"));
    }

    #[test]
    fn test_without_semicolons() {
        let static_gen = StaticGenerator::new().with_semicolons(false);
        let generator = ServerGenerator::new().with_static_generator(static_gen);
        // Use empty routers to get empty t.router({})
        let output = generator.generate(&[]);

        assert!(output.contains("const appRouter = t.router({})\n"));
        assert!(output.contains("export type AppRouter = typeof appRouter\n"));
    }

    #[test]
    fn test_multiple_procedures_in_router() {
        let generator = ServerGenerator::new();
        let router = create_test_router(
            "UserRouter",
            Some("users"),
            vec![
                create_test_procedure("getUser", ProcedureType::Query, None, None),
                create_test_procedure("createUser", ProcedureType::Mutation, None, None),
                create_test_procedure("updateUser", ProcedureType::Mutation, None, None),
            ],
        );

        let output = generator.generate_router_string(&router, 1, None);

        assert!(output.contains("getUser: publicProcedure"));
        assert!(output.contains("createUser: publicProcedure"));
        assert!(output.contains("updateUser: publicProcedure"));
        // Check procedures are separated by commas
        assert!(output.matches(".query(async () =>").count() == 1);
        assert!(output.matches(".mutation(async () =>").count() == 2);
    }

    #[test]
    fn test_output_format_matches_expected() {
        let generator = ServerGenerator::new();
        let routers = vec![create_test_router(
            "UserRouter",
            Some("users"),
            vec![create_test_procedure(
                "getUserById",
                ProcedureType::Query,
                Some("z.object({ userId: z.string() })"),
                Some("z.object({ name: z.string(), email: z.string(), password: z.string() })"),
            )],
        )];

        let output = generator.generate(&routers);

        // Verify the overall structure
        let expected_parts = [
            "import { initTRPC } from \"@trpc/server\";",
            "import { z } from \"zod\";",
            "const t = initTRPC.create();",
            "const publicProcedure = t.procedure;",
            "const appRouter = t.router({",
            "users: t.router({",
            "getUserById: publicProcedure",
            ".input(z.object({ userId: z.string() }))",
            ".output(z.object({ name: z.string(), email: z.string(), password: z.string() }))",
            ".query(async () => \"PLACEHOLDER_DO_NOT_REMOVE\" as any)",
            "})",
            "});",
            "export type AppRouter = typeof appRouter;",
        ];

        for part in expected_parts {
            assert!(
                output.contains(part),
                "Output should contain: {part}\nActual output:\n{output}"
            );
        }
    }

    #[test]
    fn test_procedure_indentation() {
        let generator = ServerGenerator::new();
        let procedure = create_test_procedure(
            "test",
            ProcedureType::Query,
            Some("z.string()"),
            Some("z.number()"),
        );

        let output = generator.generate_procedure_string(&procedure, 2, None);

        // At depth 2, the procedure name should have 4 spaces (2 * "  ")
        // The chain methods should have 6 spaces (3 * "  ")
        let lines: Vec<&str> = output.lines().collect();
        assert!(lines[0].starts_with("    test:"));
        assert!(lines[1].starts_with("      .input"));
        assert!(lines[2].starts_with("      .output"));
        assert!(lines[3].starts_with("      .query"));
    }

    #[test]
    fn test_static_generator_accessor() {
        let static_gen = StaticGenerator::new().with_single_quotes(true);
        let generator = ServerGenerator::new().with_static_generator(static_gen);

        let static_ref = generator.static_generator();
        assert!(static_ref.use_single_quotes);
    }

    // ========================================================================
    // Additional edge case tests for generator robustness (TEST-03)
    // ========================================================================

    #[test]
    fn test_generate_handles_special_characters_in_router_name() {
        let generator = ServerGenerator::new();
        let router = create_test_router(
            "SpecialRouter",
            None,
            vec![create_test_procedure(
                "getUser",
                ProcedureType::Query,
                None,
                None,
            )],
        );

        let output = generator.generate_router_string(&router, 1, None);
        // camelCase of SpecialRouter is specialRouter
        assert!(output.contains("specialRouter: t.router({"));
    }

    #[test]
    fn test_generate_handles_unicode_in_alias() {
        let generator = ServerGenerator::new();
        let router = create_test_router(
            "UserRouter",
            Some("utilisateur"),
            vec![create_test_procedure(
                "getUser",
                ProcedureType::Query,
                None,
                None,
            )],
        );

        let output = generator.generate_router_string(&router, 1, None);
        assert!(output.contains("utilisateur: t.router({"));
    }

    #[test]
    fn test_generate_handles_very_long_schema() {
        let generator = ServerGenerator::new();
        let long_schema = format!(
            "z.object({{ {} }})",
            (0..50)
                .map(|i| format!("field{i}: z.string()"))
                .collect::<Vec<_>>()
                .join(", ")
        );

        let procedure = create_test_procedure(
            "testProcedure",
            ProcedureType::Query,
            Some(&long_schema),
            None,
        );

        let output = generator.generate_procedure_string(&procedure, 1, None);
        assert!(output.contains(&long_schema));
    }

    #[test]
    fn test_generate_handles_nested_zod_schema() {
        let generator = ServerGenerator::new();
        let nested_schema = "z.object({ user: z.object({ profile: z.object({ address: z.object({ city: z.string() }) }) }) })";

        let procedure = create_test_procedure(
            "getDeepData",
            ProcedureType::Query,
            Some(nested_schema),
            None,
        );

        let output = generator.generate_procedure_string(&procedure, 1, None);
        assert!(output.contains(nested_schema));
    }

    #[test]
    fn test_generate_handles_empty_procedure_name() {
        let generator = ServerGenerator::new();
        let procedure = ProcedureMetadata {
            name: String::new(),
            procedure_type: ProcedureType::Query,
            input_schema: None,
            output_schema: None,
            method_return_type: None,
            owner_class_name: None,
            owner_file_path: None,
            input_schema_ref: None,
            output_schema_ref: None,
            schema_identifiers: Vec::new(),
        };

        let output = generator.generate_procedure_string(&procedure, 1, None);
        assert!(output.contains(": publicProcedure"));
    }

    #[test]
    fn test_generate_handles_empty_router_name() {
        let generator = ServerGenerator::new();
        let router = RouterMetadata {
            name: String::new(),
            alias: None,
            file_path: std::path::PathBuf::from("test.ts"),
            procedures: vec![],
        };

        let output = generator.generate_router_string(&router, 1, None);
        assert!(output.contains(": t.router({})"));
    }

    #[test]
    fn test_generate_with_schema_imports_empty_locations() {
        let generator = ServerGenerator::new();
        let routers = vec![create_test_router(
            "UserRouter",
            Some("users"),
            vec![ProcedureMetadata {
                name: "getUser".to_string(),
                procedure_type: ProcedureType::Query,
                input_schema: Some("userInputSchema".to_string()),
                output_schema: None,
                method_return_type: None,
                owner_class_name: None,
                owner_file_path: None,
                input_schema_ref: Some("userInputSchema".to_string()),
                output_schema_ref: None,
                schema_identifiers: Vec::new(),
            }],
        )];

        let schema_locations = HashMap::new();
        let output_path = std::path::PathBuf::from("/output/server.ts");

        let output =
            generator.generate_with_schema_imports(&routers, &schema_locations, &output_path);

        assert!(output.contains("const appRouter"));
        assert!(output.contains("export type AppRouter"));
    }

    #[test]
    fn test_generate_multiple_routers_ordering() {
        let generator = ServerGenerator::new();
        let routers = vec![
            create_test_router("ZRouter", Some("z"), vec![]),
            create_test_router("ARouter", Some("a"), vec![]),
            create_test_router("MRouter", Some("m"), vec![]),
        ];

        let output = generator.generate_app_router(&routers, None);

        let z_pos = output.find("z: t.router").unwrap_or(0);
        let a_pos = output.find("a: t.router").unwrap_or(0);
        let m_pos = output.find("m: t.router").unwrap_or(0);

        assert!(z_pos < a_pos, "Order should be preserved (z before a)");
        assert!(a_pos < m_pos, "Order should be preserved (a before m)");
    }

    #[test]
    fn test_generate_procedure_output_only() {
        let generator = ServerGenerator::new();
        let procedure = create_test_procedure(
            "getUser",
            ProcedureType::Query,
            None,
            Some("z.object({ name: z.string() })"),
        );

        let output = generator.generate_procedure_string(&procedure, 1, None);

        assert!(!output.contains(".input("));
        assert!(output.contains(".output(z.object({ name: z.string() }))"));
    }

    #[test]
    fn test_camel_case_single_character() {
        assert_eq!(to_camel_case("X"), "x");
    }

    #[test]
    fn test_camel_case_already_lowercase() {
        assert_eq!(to_camel_case("already"), "already");
    }

    #[test]
    fn test_camel_case_numeric_suffix() {
        assert_eq!(to_camel_case("Router2"), "router2");
    }

    #[test]
    fn test_generate_handles_quotes_in_schema() {
        let generator = ServerGenerator::new();
        let schema_with_quotes = r#"z.enum(["active", "inactive"])"#;

        let procedure = create_test_procedure(
            "getStatus",
            ProcedureType::Query,
            Some(schema_with_quotes),
            None,
        );

        let output = generator.generate_procedure_string(&procedure, 1, None);
        assert!(output.contains(r#"z.enum(["active", "inactive"])"#));
    }

    #[test]
    fn test_generate_deep_nesting_depth() {
        let generator = ServerGenerator::new();
        let procedure = create_test_procedure("deep", ProcedureType::Query, None, None);

        let output = generator.generate_procedure_string(&procedure, 10, None);

        let first_line = output.lines().next().unwrap();
        let expected_indent = "  ".repeat(10);
        assert!(first_line.starts_with(&expected_indent));
    }

    #[test]
    fn test_extract_schema_refs_both_present() {
        let procedure = ProcedureMetadata {
            name: "test".to_string(),
            procedure_type: ProcedureType::Query,
            input_schema: Some("inputSchema".to_string()),
            output_schema: Some("outputSchema".to_string()),
            method_return_type: None,
            owner_class_name: None,
            owner_file_path: None,
            input_schema_ref: Some("InputRef".to_string()),
            output_schema_ref: Some("OutputRef".to_string()),
            schema_identifiers: Vec::new(),
        };

        let refs = ServerGenerator::extract_schema_refs(&procedure);
        assert_eq!(refs.len(), 2);
        assert!(refs.contains(&"InputRef"));
        assert!(refs.contains(&"OutputRef"));
    }

    #[test]
    fn test_extract_schema_refs_none_present() {
        let procedure = ProcedureMetadata {
            name: "test".to_string(),
            procedure_type: ProcedureType::Query,
            input_schema: None,
            output_schema: None,
            method_return_type: None,
            owner_class_name: None,
            owner_file_path: None,
            input_schema_ref: None,
            output_schema_ref: None,
            schema_identifiers: Vec::new(),
        };

        let refs = ServerGenerator::extract_schema_refs(&procedure);
        assert!(refs.is_empty());
    }

    #[test]
    fn test_generate_file_header_present() {
        let generator = ServerGenerator::new();
        let output = generator.generate(&[]);

        assert!(output.contains("AUTO-GENERATED FILE - DO NOT EDIT!"));
        assert!(output.contains("nestjs-trpc"));
    }

    // ========================================================================
    // Router alias merging tests
    // ========================================================================

    #[test]
    fn test_merge_routers_with_same_alias() {
        let generator = ServerGenerator::new();
        let routers = vec![
            create_test_router(
                "UserRouterA",
                Some("users"),
                vec![create_test_procedure(
                    "getUser",
                    ProcedureType::Query,
                    None,
                    None,
                )],
            ),
            create_test_router(
                "UserRouterB",
                Some("users"),
                vec![create_test_procedure(
                    "createUser",
                    ProcedureType::Mutation,
                    None,
                    None,
                )],
            ),
        ];

        let output = generator.generate_app_router(&routers, None);

        assert_eq!(
            output.matches("users: t.router(").count(),
            1,
            "Should produce a single merged router"
        );
        assert!(output.contains("getUser: publicProcedure"));
        assert!(output.contains("createUser: publicProcedure"));
    }

    #[test]
    fn test_merge_routers_with_same_camel_case_name() {
        let generator = ServerGenerator::new();
        let routers = vec![
            create_test_router(
                "UserRouter",
                None,
                vec![create_test_procedure(
                    "getUser",
                    ProcedureType::Query,
                    None,
                    None,
                )],
            ),
            create_test_router(
                "UserRouter",
                None,
                vec![create_test_procedure(
                    "deleteUser",
                    ProcedureType::Mutation,
                    None,
                    None,
                )],
            ),
        ];

        let output = generator.generate_app_router(&routers, None);

        assert_eq!(
            output.matches("userRouter: t.router(").count(),
            1,
            "Should produce a single merged router"
        );
        assert!(output.contains("getUser: publicProcedure"));
        assert!(output.contains("deleteUser: publicProcedure"));
    }

    #[test]
    fn test_merge_preserves_insertion_order() {
        let generator = ServerGenerator::new();
        let routers = vec![
            create_test_router(
                "PostRouter",
                Some("posts"),
                vec![create_test_procedure(
                    "getPost",
                    ProcedureType::Query,
                    None,
                    None,
                )],
            ),
            create_test_router(
                "UserRouter",
                Some("users"),
                vec![create_test_procedure(
                    "getUser",
                    ProcedureType::Query,
                    None,
                    None,
                )],
            ),
            create_test_router(
                "PostRouterExtended",
                Some("posts"),
                vec![create_test_procedure(
                    "createPost",
                    ProcedureType::Mutation,
                    None,
                    None,
                )],
            ),
        ];

        let output = generator.generate_app_router(&routers, None);

        let posts_pos = output.find("posts: t.router(").unwrap();
        let users_pos = output.find("users: t.router(").unwrap();

        assert!(
            posts_pos < users_pos,
            "Merged router should appear at its first occurrence position"
        );
        assert_eq!(
            output.matches("posts: t.router(").count(),
            1,
            "Duplicate alias should be merged"
        );
    }

    #[test]
    fn test_merge_mixed_unique_and_shared_aliases() {
        let generator = ServerGenerator::new();
        let routers = vec![
            create_test_router(
                "UserRouterA",
                Some("users"),
                vec![create_test_procedure(
                    "getUser",
                    ProcedureType::Query,
                    None,
                    None,
                )],
            ),
            create_test_router(
                "PostRouter",
                Some("posts"),
                vec![create_test_procedure(
                    "getPost",
                    ProcedureType::Query,
                    None,
                    None,
                )],
            ),
            create_test_router(
                "UserRouterB",
                Some("users"),
                vec![create_test_procedure(
                    "updateUser",
                    ProcedureType::Mutation,
                    None,
                    None,
                )],
            ),
        ];

        let output = generator.generate_app_router(&routers, None);

        assert_eq!(output.matches("users: t.router(").count(), 1);
        assert_eq!(output.matches("posts: t.router(").count(), 1);
        assert!(output.contains("getUser: publicProcedure"));
        assert!(output.contains("updateUser: publicProcedure"));
        assert!(output.contains("getPost: publicProcedure"));
    }

    #[test]
    fn test_merge_three_routers_same_alias() {
        let generator = ServerGenerator::new();
        let routers = vec![
            create_test_router(
                "A",
                Some("shared"),
                vec![create_test_procedure("a", ProcedureType::Query, None, None)],
            ),
            create_test_router(
                "B",
                Some("shared"),
                vec![create_test_procedure(
                    "b",
                    ProcedureType::Mutation,
                    None,
                    None,
                )],
            ),
            create_test_router(
                "C",
                Some("shared"),
                vec![create_test_procedure(
                    "c",
                    ProcedureType::Query,
                    Some("z.string()"),
                    None,
                )],
            ),
        ];

        let output = generator.generate_app_router(&routers, None);

        assert_eq!(output.matches("shared: t.router(").count(), 1);
        assert!(output.contains("a: publicProcedure"));
        assert!(output.contains("b: publicProcedure"));
        assert!(output.contains("c: publicProcedure"));
        assert!(output.contains(".input(z.string())"));
    }

    #[test]
    fn test_merge_routers_empty_plus_nonempty() {
        let generator = ServerGenerator::new();
        let routers = vec![
            create_test_router("Empty", Some("shared"), vec![]),
            create_test_router(
                "NonEmpty",
                Some("shared"),
                vec![create_test_procedure(
                    "action",
                    ProcedureType::Query,
                    None,
                    None,
                )],
            ),
        ];

        let output = generator.generate_app_router(&routers, None);

        assert_eq!(output.matches("shared: t.router(").count(), 1);
        assert!(output.contains("action: publicProcedure"));
    }

    // ========================================================================
    // Transformer integration tests
    // ========================================================================

    #[test]
    fn test_generate_complete_file_with_transformer() {
        let transformer = crate::parser::module::TransformerInfo {
            package_name: "superjson".to_string(),
            import_name: "superjson".to_string(),
            is_default_import: true,
        };
        let static_generator = StaticGenerator::new().with_transformer(Some(transformer));
        let generator = ServerGenerator::new().with_static_generator(static_generator);

        let routers = vec![create_test_router(
            "UserRouter",
            Some("users"),
            vec![create_test_procedure(
                "getUser",
                ProcedureType::Query,
                None,
                None,
            )],
        )];

        let output = generator.generate(&routers);

        assert!(output.contains("import superjson from \"superjson\";"));
        assert!(output.contains("const t = initTRPC.create({ transformer: superjson });"));
        assert!(output.contains("users: t.router({"));
        assert!(output.contains("export type AppRouter = typeof appRouter;"));
    }

    #[test]
    fn test_generate_complete_file_without_transformer() {
        let generator = ServerGenerator::new();
        let routers = vec![create_test_router("Test", Some("test"), vec![])];

        let output = generator.generate(&routers);

        assert!(output.contains("const t = initTRPC.create();"));
        assert!(!output.contains("transformer"));
        assert!(!output.contains("superjson"));
    }
}
