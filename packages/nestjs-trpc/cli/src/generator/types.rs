use crate::generator::StaticGenerator;
use crate::parser::context::ContextInfo;
use crate::parser::middleware::MiddlewareInfo;
use std::fmt::Write;

const FILE_HEADER: &str = r"/**
 * AUTO-GENERATED FILE - DO NOT EDIT!
 *
 * This file was automatically generated by nestjs-trpc.
 * Any manual changes will be overwritten on the next generation.
 *
 * Command: `npx nestjs-trpc generate`
 * Learn more: https://nestjs-trpc.io
 */
";

#[derive(Debug, Clone)]
pub struct TypesGenerator {
    static_generator: StaticGenerator,
}

impl Default for TypesGenerator {
    fn default() -> Self {
        Self::new()
    }
}

impl TypesGenerator {
    #[must_use]
    pub const fn new() -> Self {
        Self {
            static_generator: StaticGenerator::new(),
        }
    }

    #[must_use]
    pub const fn with_static_generator(static_generator: StaticGenerator) -> Self {
        Self { static_generator }
    }

    #[must_use]
    pub fn generate(
        &self,
        context: Option<&ContextInfo>,
        middlewares: &[MiddlewareInfo],
    ) -> String {
        let mut output = String::new();

        output.push_str(FILE_HEADER);
        output.push('\n');

        if let Some(context_info) = context {
            let context_type = self.generate_context_type(context_info);
            output.push_str(&context_type);
            output.push('\n');
        }

        for middleware in middlewares {
            self.append_middleware_interface(&mut output, middleware);
        }

        output
    }

    fn generate_context_type(&self, context: &ContextInfo) -> String {
        let terminator = self.terminator();
        format!(
            "export type Context = {}{terminator}\n",
            context.return_type
        )
    }

    fn append_middleware_interface(&self, output: &mut String, middleware: &MiddlewareInfo) {
        if middleware.context_properties.is_empty() {
            return;
        }
        let interface = self.generate_middleware_interface(middleware);
        output.push_str(&interface);
        output.push('\n');
    }

    fn generate_middleware_interface(&self, middleware: &MiddlewareInfo) -> String {
        let terminator = self.terminator();
        let interface_name = format!("{}Context", middleware.class_name);

        let mut output = String::new();
        let _ = writeln!(
            output,
            "export interface {interface_name} extends Context {{"
        );

        for property in &middleware.context_properties {
            let _ = writeln!(
                output,
                "  {}: {}{terminator}",
                property.name, property.type_string
            );
        }

        let _ = writeln!(output, "}}");

        output
    }

    const fn terminator(&self) -> &str {
        if self.static_generator.use_semicolons {
            ";"
        } else {
            ""
        }
    }
}

#[must_use]
pub fn generate_types_file(
    context: Option<&ContextInfo>,
    middlewares: &[MiddlewareInfo],
) -> String {
    TypesGenerator::new().generate(context, middlewares)
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    fn create_context_info() -> ContextInfo {
        ContextInfo {
            class_name: "AppContext".to_string(),
            file_path: PathBuf::from("src/app.context.ts"),
            return_type: "{ req: any; auth: { user: User } }".to_string(),
        }
    }

    fn create_middleware_info() -> MiddlewareInfo {
        use crate::parser::middleware::ContextProperty;
        MiddlewareInfo {
            class_name: "ProtectedMiddleware".to_string(),
            file_path: PathBuf::from("src/protected.middleware.ts"),
            context_properties: vec![ContextProperty {
                name: "ben".to_string(),
                type_string: "number".to_string(),
            }],
        }
    }

    #[test]
    fn test_generator_creation() {
        let generator = TypesGenerator::new();
        assert!(generator.static_generator.use_semicolons);
    }

    #[test]
    fn test_generator_default() {
        let generator = TypesGenerator::default();
        assert!(generator.static_generator.use_semicolons);
    }

    #[test]
    fn test_generate_with_context_only() {
        let generator = TypesGenerator::new();
        let context = create_context_info();
        let output = generator.generate(Some(&context), &[]);

        assert!(output.contains("AUTO-GENERATED FILE"));
        assert!(output.contains("export type Context = { req: any; auth: { user: User } };"));
    }

    #[test]
    fn test_generate_with_middleware_only() {
        let generator = TypesGenerator::new();
        let middleware = create_middleware_info();
        let output = generator.generate(None, &[middleware]);

        assert!(output.contains("AUTO-GENERATED FILE"));
        assert!(output.contains("export interface ProtectedMiddlewareContext extends Context {"));
        assert!(output.contains("ben: number;"));
    }

    #[test]
    fn test_generate_with_context_and_middleware() {
        let generator = TypesGenerator::new();
        let context = create_context_info();
        let middleware = create_middleware_info();
        let output = generator.generate(Some(&context), &[middleware]);

        assert!(output.contains("export type Context = { req: any; auth: { user: User } };"));
        assert!(output.contains("export interface ProtectedMiddlewareContext extends Context {"));
        assert!(output.contains("ben: number;"));
    }

    #[test]
    fn test_generate_empty() {
        let generator = TypesGenerator::new();
        let output = generator.generate(None, &[]);

        assert!(output.contains("AUTO-GENERATED FILE"));
        assert!(!output.contains("export type Context"));
        assert!(!output.contains("export interface"));
    }

    #[test]
    fn test_generate_multiple_middlewares() {
        use crate::parser::middleware::ContextProperty;

        let generator = TypesGenerator::new();
        let context = create_context_info();

        let middleware1 = MiddlewareInfo {
            class_name: "AuthMiddleware".to_string(),
            file_path: PathBuf::from("auth.middleware.ts"),
            context_properties: vec![
                ContextProperty {
                    name: "userId".to_string(),
                    type_string: "string".to_string(),
                },
                ContextProperty {
                    name: "isAdmin".to_string(),
                    type_string: "boolean".to_string(),
                },
            ],
        };

        let middleware2 = MiddlewareInfo {
            class_name: "LoggingMiddleware".to_string(),
            file_path: PathBuf::from("logging.middleware.ts"),
            context_properties: vec![],
        };

        let middleware3 = MiddlewareInfo {
            class_name: "RateLimitMiddleware".to_string(),
            file_path: PathBuf::from("rate-limit.middleware.ts"),
            context_properties: vec![ContextProperty {
                name: "requestCount".to_string(),
                type_string: "number".to_string(),
            }],
        };

        let output = generator.generate(Some(&context), &[middleware1, middleware2, middleware3]);

        assert!(output.contains("export interface AuthMiddlewareContext extends Context {"));
        assert!(output.contains("userId: string;"));
        assert!(output.contains("isAdmin: boolean;"));

        assert!(!output.contains("LoggingMiddlewareContext"));

        assert!(output.contains("export interface RateLimitMiddlewareContext extends Context {"));
        assert!(output.contains("requestCount: number;"));
    }

    #[test]
    fn test_generate_without_semicolons() {
        let static_generator = StaticGenerator::new().with_semicolons(false);
        let generator = TypesGenerator::with_static_generator(static_generator);
        let context = create_context_info();
        let middleware = create_middleware_info();

        let output = generator.generate(Some(&context), &[middleware]);

        assert!(!output.contains("};"));
        assert!(output.contains("ben: number\n"));
    }

    #[test]
    fn test_convenience_function() {
        let context = create_context_info();
        let middleware = create_middleware_info();

        let output = generate_types_file(Some(&context), &[middleware]);

        assert!(output.contains("export type Context"));
        assert!(output.contains("export interface ProtectedMiddlewareContext"));
    }

    #[test]
    fn test_file_header() {
        let generator = TypesGenerator::new();
        let output = generator.generate(None, &[]);

        assert!(output.starts_with("/**\n"));
        assert!(output.contains("AUTO-GENERATED FILE - DO NOT EDIT!"));
        assert!(output.contains("npx nestjs-trpc generate"));
        assert!(output.contains("nestjs-trpc.io"));
    }

    // ========================================================================
    // Additional edge case tests for types generator (TEST-03)
    // ========================================================================

    #[test]
    fn test_generate_context_with_complex_return_type() {
        let generator = TypesGenerator::new();
        let context = ContextInfo {
            class_name: "ComplexContext".to_string(),
            file_path: PathBuf::from("complex.context.ts"),
            return_type: "{ req: Request; res: Response; db: Database; cache: Redis; session: Session | null }".to_string(),
        };

        let output = generator.generate(Some(&context), &[]);

        assert!(output.contains("export type Context = { req: Request; res: Response; db: Database; cache: Redis; session: Session | null };"));
    }

    #[test]
    fn test_generate_context_with_generic_type() {
        let generator = TypesGenerator::new();
        let context = ContextInfo {
            class_name: "GenericContext".to_string(),
            file_path: PathBuf::from("generic.context.ts"),
            return_type: "{ data: Array<Record<string, unknown>> }".to_string(),
        };

        let output = generator.generate(Some(&context), &[]);

        assert!(output.contains("export type Context = { data: Array<Record<string, unknown>> };"));
    }

    #[test]
    fn test_generate_middleware_with_many_properties() {
        use crate::parser::middleware::ContextProperty;

        let generator = TypesGenerator::new();
        let middleware = MiddlewareInfo {
            class_name: "ComplexMiddleware".to_string(),
            file_path: PathBuf::from("complex.middleware.ts"),
            context_properties: vec![
                ContextProperty {
                    name: "userId".to_string(),
                    type_string: "string".to_string(),
                },
                ContextProperty {
                    name: "roles".to_string(),
                    type_string: "string[]".to_string(),
                },
                ContextProperty {
                    name: "permissions".to_string(),
                    type_string: "Set<string>".to_string(),
                },
                ContextProperty {
                    name: "metadata".to_string(),
                    type_string: "Record<string, any>".to_string(),
                },
                ContextProperty {
                    name: "timestamp".to_string(),
                    type_string: "Date".to_string(),
                },
            ],
        };

        let output = generator.generate(None, &[middleware]);

        assert!(output.contains("export interface ComplexMiddlewareContext extends Context {"));
        assert!(output.contains("userId: string;"));
        assert!(output.contains("roles: string[];"));
        assert!(output.contains("permissions: Set<string>;"));
        assert!(output.contains("metadata: Record<string, any>;"));
        assert!(output.contains("timestamp: Date;"));
    }

    #[test]
    fn test_generate_middleware_with_empty_name() {
        use crate::parser::middleware::ContextProperty;

        let generator = TypesGenerator::new();
        let middleware = MiddlewareInfo {
            class_name: String::new(),
            file_path: PathBuf::from("empty.middleware.ts"),
            context_properties: vec![ContextProperty {
                name: "field".to_string(),
                type_string: "string".to_string(),
            }],
        };

        let output = generator.generate(None, &[middleware]);
        assert!(output.contains("export interface Context extends Context {"));
    }

    #[test]
    fn test_generate_middleware_with_special_property_names() {
        use crate::parser::middleware::ContextProperty;

        let generator = TypesGenerator::new();
        let middleware = MiddlewareInfo {
            class_name: "SpecialMiddleware".to_string(),
            file_path: PathBuf::from("special.middleware.ts"),
            context_properties: vec![
                ContextProperty {
                    name: "$special".to_string(),
                    type_string: "any".to_string(),
                },
                ContextProperty {
                    name: "_private".to_string(),
                    type_string: "string".to_string(),
                },
            ],
        };

        let output = generator.generate(None, &[middleware]);

        assert!(output.contains("$special: any;"));
        assert!(output.contains("_private: string;"));
    }

    #[test]
    fn test_generate_context_with_empty_return_type() {
        let generator = TypesGenerator::new();
        let context = ContextInfo {
            class_name: "EmptyContext".to_string(),
            file_path: PathBuf::from("empty.context.ts"),
            return_type: "{}".to_string(),
        };

        let output = generator.generate(Some(&context), &[]);

        assert!(output.contains("export type Context = {};"));
    }

    #[test]
    fn test_generate_preserves_middleware_order() {
        use crate::parser::middleware::ContextProperty;

        let generator = TypesGenerator::new();
        let middlewares = vec![
            MiddlewareInfo {
                class_name: "FirstMiddleware".to_string(),
                file_path: PathBuf::from("first.middleware.ts"),
                context_properties: vec![ContextProperty {
                    name: "first".to_string(),
                    type_string: "number".to_string(),
                }],
            },
            MiddlewareInfo {
                class_name: "SecondMiddleware".to_string(),
                file_path: PathBuf::from("second.middleware.ts"),
                context_properties: vec![ContextProperty {
                    name: "second".to_string(),
                    type_string: "number".to_string(),
                }],
            },
            MiddlewareInfo {
                class_name: "ThirdMiddleware".to_string(),
                file_path: PathBuf::from("third.middleware.ts"),
                context_properties: vec![ContextProperty {
                    name: "third".to_string(),
                    type_string: "number".to_string(),
                }],
            },
        ];

        let output = generator.generate(None, &middlewares);

        let first_pos = output.find("FirstMiddlewareContext").unwrap();
        let second_pos = output.find("SecondMiddlewareContext").unwrap();
        let third_pos = output.find("ThirdMiddlewareContext").unwrap();

        assert!(first_pos < second_pos, "First should come before Second");
        assert!(second_pos < third_pos, "Second should come before Third");
    }

    #[test]
    fn test_generate_context_and_middleware_together() {
        use crate::parser::middleware::ContextProperty;

        let generator = TypesGenerator::new();
        let context = create_context_info();
        let middleware = MiddlewareInfo {
            class_name: "AuthMiddleware".to_string(),
            file_path: PathBuf::from("auth.middleware.ts"),
            context_properties: vec![ContextProperty {
                name: "isAuthenticated".to_string(),
                type_string: "boolean".to_string(),
            }],
        };

        let output = generator.generate(Some(&context), &[middleware]);

        let context_pos = output.find("export type Context").unwrap();
        let middleware_pos = output
            .find("export interface AuthMiddlewareContext")
            .unwrap();

        assert!(
            context_pos < middleware_pos,
            "Context type should come before middleware interfaces"
        );
    }
}
